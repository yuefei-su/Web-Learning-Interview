## 0.1+0.2!=0.3怎么处理

计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是`0.0001100110011001100...`（1100循环），0.2的二进制是：`0.00110011001100...`（1100循环），这两个数的二进制都是无限循环的数。根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：`0.30000000000000004`。  

#### 1. 把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完成后再进行降级（除以10的n次幂）
```JavaScript
(0.1*10 + 0.2*10)/10 == 0.3 //true
```

#### 2. 一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了`Number.EPSILON`属性，而它的值就是2-52，只要判断`0.1+0.2-0.3`是否小于`Number.EPSILON`，如果小于，就可以判断为0.1+0.2 ===0.3

```js
function numberepsilon(arg1,arg2){                   
  return Math.abs(arg1 - arg2) < Number.EPSILON;        
}        

console.log(numberepsilon(0.1 + 0.2, 0.3)); // true
```


#### 3. `toFixed(num)` 方法可把 Number 四舍五入为指定小数位数的数字

```js
(0.1 + 0.2).toFixed(2) // 0.3，注意：toFixed为四舍五入
```

#### 4. 浮点数数据存储

和其它语言如Java和Python不同，JavaScript中所有数字包括整数和小数都只有一种类型 — Number。它的实现遵循 IEEE 754 标准，使用64位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有float 32位单精度）。这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。  

64位比特又可分为三个部分：
- 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数

- 指数位E：中间的 11 位存储指数（exponent），用来表示次方数

- 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

![](https://raw.githubusercontent.com/yuefei-su/My-DrawingBed/main/notes/storage.png)

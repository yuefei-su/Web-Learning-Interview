## 作用域和作用域链


变量提升（暂时性死区：let声明变量前，该变量都不可用）  
先变量提升再函数提升

怎么理解JS 静态作用域  
如何使其拥有动态作用域的特性


### 1. 全局作用域

- 最外层函数和最外层函数外面定义的变量拥有全局作用域
- 所有未定义直接赋值的变量自动声明为全局作用域
- 所有window对象的属性拥有全局作用域
- 全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。

### 2. 函数作用域

- 函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到
- 作用域是分层的，内层作用域可以访问外层作用域，反之不行
```js
function greet() {
  var greeting = 'Hello World!';
  console.log(greeting);
}
// 打印 'Hello World!'
greet();
// 报错： Uncaught ReferenceError: greeting is not defined
console.log(greeting);
```


### 3. 块级作用域

- 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由`{ }`包裹的代码片段）
- let和const声明的变量不会有变量提升，也不可以重复声明
- 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。

### 4. 作用域链

在**当前作用域**中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去**父级作用域**查找，依次向上级作用域查找，**直到访问到window对象**就被终止，这一层层的关系就是作用域链。

作用域链的作用是**保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。**

### 5. 静态作用域
词法作用域，又叫静态作用域，**变量被创建时（写代码时）它的作用域就确定好了**，而非执行阶段确定的。
```js
var a = 2;
function foo(){
    console.log(a)
}
function bar(){
    var a = 3;
    foo();
}
bar()//2
```
![上图代码解析](https://raw.githubusercontent.com/yuefei-su/My-DrawingBed/main/notes/29fab3d0-718f-11eb-85f6-6fac77c0c9b3.png)
由于JavaScript遵循词法作用域，相同层级的 foo 和 bar 就没有办法访问到彼此块作用域中的变量，所以输出2